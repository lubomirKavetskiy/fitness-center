{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useQuery, useQueryClient } from 'react-query';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { queryKeys } from '../../../react-query/constants';\nimport { clearStoredUser, getStoredUser, setStoredUser } from '../../../user-storage';\n\nasync function getUser(user, signal) {\n  console.log({\n    user\n  });\n  if (!user) return null;\n  const {\n    data\n  } = await axiosInstance.get(`/user/${user.id}`, {\n    headers: getJWTHeader(user)\n  });\n  return data.user;\n}\n\nexport function useUser() {\n  _s();\n\n  const queryClient = useQueryClient();\n  const {\n    data: user\n  } = useQuery(queryKeys.user, ({\n    signal\n  }) => getUser(user, signal), {\n    initialData: getStoredUser,\n    onSuccess: received => {\n      if (!received) {\n        clearStoredUser();\n      } else {\n        setStoredUser(received);\n      }\n    }\n  }); // update a user in the cash\n  // in this way will be called onSuccess callback in useQuery(queryKeys.user) as well, I mean setStoredUser(received)\n\n  function updateUser(newUser) {\n    queryClient.setQueryData(queryKeys.user, newUser);\n  } // meant to be called from useAuth\n\n\n  function clearUser() {\n    // set data to cache\n    queryClient.setQueryData(queryKeys.user, null); // remove data from cache\n\n    queryClient.removeQueries([queryKeys.appointments, queryKeys.user]);\n  }\n\n  return {\n    user,\n    updateUser,\n    clearUser\n  };\n}\n\n_s(useUser, \"NmeRR1fLBB2wYNsHdaD9UXHQupU=\", false, function () {\n  return [useQueryClient, useQuery];\n});","map":{"version":3,"sources":["/Users/work/Documents/Projects/study/react-query/base-lazy-days/client/src/components/user/hooks/useUser.ts"],"names":["useQuery","useQueryClient","axiosInstance","getJWTHeader","queryKeys","clearStoredUser","getStoredUser","setStoredUser","getUser","user","signal","console","log","data","get","id","headers","useUser","queryClient","initialData","onSuccess","received","updateUser","newUser","setQueryData","clearUser","removeQueries","appointments"],"mappings":";;AACA,SAASA,QAAT,EAAmBC,cAAnB,QAAyC,aAAzC;AAGA,SAASC,aAAT,EAAwBC,YAAxB,QAA4C,wBAA5C;AACA,SAASC,SAAT,QAA0B,gCAA1B;AACA,SACEC,eADF,EAEEC,aAFF,EAGEC,aAHF,QAIO,uBAJP;;AAMA,eAAeC,OAAf,CACEC,IADF,EAEEC,MAFF,EAGwB;AACtBC,EAAAA,OAAO,CAACC,GAAR,CAAY;AAAEH,IAAAA;AAAF,GAAZ;AACA,MAAI,CAACA,IAAL,EAAW,OAAO,IAAP;AACX,QAAM;AAAEI,IAAAA;AAAF,MAA0C,MAAMX,aAAa,CAACY,GAAd,CACnD,SAAQL,IAAI,CAACM,EAAG,EADmC,EAEpD;AACEC,IAAAA,OAAO,EAAEb,YAAY,CAACM,IAAD;AADvB,GAFoD,CAAtD;AAMA,SAAOI,IAAI,CAACJ,IAAZ;AACD;;AAQD,OAAO,SAASQ,OAAT,GAA4B;AAAA;;AACjC,QAAMC,WAAW,GAAGjB,cAAc,EAAlC;AACA,QAAM;AAAEY,IAAAA,IAAI,EAAEJ;AAAR,MAAiBT,QAAQ,CAC7BI,SAAS,CAACK,IADmB,EAE7B,CAAC;AAAEC,IAAAA;AAAF,GAAD,KAAgBF,OAAO,CAACC,IAAD,EAAOC,MAAP,CAFM,EAG7B;AACES,IAAAA,WAAW,EAAEb,aADf;AAEEc,IAAAA,SAAS,EAAGC,QAAD,IAA2B;AACpC,UAAI,CAACA,QAAL,EAAe;AACbhB,QAAAA,eAAe;AAChB,OAFD,MAEO;AACLE,QAAAA,aAAa,CAACc,QAAD,CAAb;AACD;AACF;AARH,GAH6B,CAA/B,CAFiC,CAiBjC;AACA;;AACA,WAASC,UAAT,CAAoBC,OAApB,EAAyC;AACvCL,IAAAA,WAAW,CAACM,YAAZ,CAAyBpB,SAAS,CAACK,IAAnC,EAAyCc,OAAzC;AACD,GArBgC,CAuBjC;;;AACA,WAASE,SAAT,GAAqB;AACnB;AACAP,IAAAA,WAAW,CAACM,YAAZ,CAAyBpB,SAAS,CAACK,IAAnC,EAAyC,IAAzC,EAFmB,CAGnB;;AACAS,IAAAA,WAAW,CAACQ,aAAZ,CAA0B,CAACtB,SAAS,CAACuB,YAAX,EAAyBvB,SAAS,CAACK,IAAnC,CAA1B;AACD;;AAED,SAAO;AAAEA,IAAAA,IAAF;AAAQa,IAAAA,UAAR;AAAoBG,IAAAA;AAApB,GAAP;AACD;;GAhCeR,O;UACMhB,c,EACGD,Q","sourcesContent":["import { AxiosResponse } from 'axios';\nimport { useQuery, useQueryClient } from 'react-query';\n\nimport type { User } from '../../../../../shared/types';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { queryKeys } from '../../../react-query/constants';\nimport {\n  clearStoredUser,\n  getStoredUser,\n  setStoredUser,\n} from '../../../user-storage';\n\nasync function getUser(\n  user: User | null,\n  signal: AbortSignal,\n): Promise<User | null> {\n  console.log({ user });\n  if (!user) return null;\n  const { data }: AxiosResponse<{ user: User }> = await axiosInstance.get(\n    `/user/${user.id}`,\n    {\n      headers: getJWTHeader(user),\n    },\n  );\n  return data.user;\n}\n\ninterface UseUser {\n  user: User | null;\n  updateUser: (user: User) => void;\n  clearUser: () => void;\n}\n\nexport function useUser(): UseUser {\n  const queryClient = useQueryClient();\n  const { data: user } = useQuery(\n    queryKeys.user,\n    ({ signal }) => getUser(user, signal),\n    {\n      initialData: getStoredUser,\n      onSuccess: (received: User | null) => {\n        if (!received) {\n          clearStoredUser();\n        } else {\n          setStoredUser(received);\n        }\n      },\n    },\n  );\n\n  // update a user in the cash\n  // in this way will be called onSuccess callback in useQuery(queryKeys.user) as well, I mean setStoredUser(received)\n  function updateUser(newUser: User): void {\n    queryClient.setQueryData(queryKeys.user, newUser);\n  }\n\n  // meant to be called from useAuth\n  function clearUser() {\n    // set data to cache\n    queryClient.setQueryData(queryKeys.user, null);\n    // remove data from cache\n    queryClient.removeQueries([queryKeys.appointments, queryKeys.user]);\n  }\n\n  return { user, updateUser, clearUser };\n}\n"]},"metadata":{},"sourceType":"module"}