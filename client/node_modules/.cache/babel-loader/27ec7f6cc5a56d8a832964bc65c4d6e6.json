{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCustomToast } from 'components/app/hooks/useCustomToast';\nimport jsonpatch from 'fast-json-patch';\nimport { useMutation, useQueryClient } from 'react-query';\nimport { queryKeys } from 'react-query/constants';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { useUser } from './useUser'; // for when we need a server function\n\nasync function patchUserOnServer(newData, originalData) {\n  if (!newData || !originalData) return null; // create a patch for the difference between newData and originalData\n\n  const patch = jsonpatch.compare(originalData, newData); // send patched data to the server\n\n  const {\n    data\n  } = await axiosInstance.patch(`/user/${originalData.id}`, {\n    patch\n  }, {\n    headers: getJWTHeader(originalData)\n  });\n  return data.user;\n} // TODO: update type to UseMutateFunction type\n\n\nexport function usePatchUser() {\n  _s();\n\n  const {\n    user,\n    updateUser\n  } = useUser();\n  const toast = useCustomToast();\n  const queryClient = useQueryClient();\n  const {\n    mutate: patchUser\n  } = useMutation(newUserData => patchUserOnServer(newUserData, user), {\n    // onMutate returns context that is passed to onError\n    onMutate: async newData => {\n      // cancel any outdoing queries for user data, so old server data\n      // doesn't overwrite our optimistic update\n      queryClient.cancelQueries(queryKeys.user); // snapshot of previuos user value\n\n      const prevUserData = queryClient.getQueriesData(queryKeys.user); // optimistically update the cache with new user value\n\n      updateUser(newData); // return the context object with snapshotted value\n\n      return {\n        prevUserData\n      };\n    },\n    onError: (_error, _newData, context) => {\n      // roll back cache to saved value\n      if (context === null || context === void 0 ? void 0 : context.prevUserData) {\n        updateUser(context === null || context === void 0 ? void 0 : context.prevUserData);\n      }\n    },\n    onSuccess: userData => {\n      if (userData) {\n        // no longer need it after implementing onMutate\n        // updateUser(userData);\n        toast({\n          title: 'User updated',\n          status: 'success'\n        });\n      }\n    },\n    onSettled: () => {// invalidate user data (query) to make sure we're in syncwith server data\n    }\n  });\n  return patchUser;\n}\n\n_s(usePatchUser, \"7cj5AKVt9P+SDRO7AdycYdtc0IE=\", false, function () {\n  return [useUser, useCustomToast, useQueryClient, useMutation];\n});","map":{"version":3,"sources":["/Users/work/Documents/Projects/study/react-query/base-lazy-days/client/src/components/user/hooks/usePatchUser.ts"],"names":["useCustomToast","jsonpatch","useMutation","useQueryClient","queryKeys","axiosInstance","getJWTHeader","useUser","patchUserOnServer","newData","originalData","patch","compare","data","id","headers","user","usePatchUser","updateUser","toast","queryClient","mutate","patchUser","newUserData","onMutate","cancelQueries","prevUserData","getQueriesData","onError","_error","_newData","context","onSuccess","userData","title","status","onSettled"],"mappings":";;AAAA,SAASA,cAAT,QAA+B,qCAA/B;AACA,OAAOC,SAAP,MAAsB,iBAAtB;AACA,SAA4BC,WAA5B,EAAyCC,cAAzC,QAA+D,aAA/D;AACA,SAASC,SAAT,QAA0B,uBAA1B;AAGA,SAASC,aAAT,EAAwBC,YAAxB,QAA4C,wBAA5C;AACA,SAASC,OAAT,QAAwB,WAAxB,C,CAEA;;AACA,eAAeC,iBAAf,CACEC,OADF,EAEEC,YAFF,EAGwB;AACtB,MAAI,CAACD,OAAD,IAAY,CAACC,YAAjB,EAA+B,OAAO,IAAP,CADT,CAEtB;;AACA,QAAMC,KAAK,GAAGV,SAAS,CAACW,OAAV,CAAkBF,YAAlB,EAAgCD,OAAhC,CAAd,CAHsB,CAKtB;;AACA,QAAM;AAAEI,IAAAA;AAAF,MAAW,MAAMR,aAAa,CAACM,KAAd,CACpB,SAAQD,YAAY,CAACI,EAAG,EADJ,EAErB;AAAEH,IAAAA;AAAF,GAFqB,EAGrB;AACEI,IAAAA,OAAO,EAAET,YAAY,CAACI,YAAD;AADvB,GAHqB,CAAvB;AAOA,SAAOG,IAAI,CAACG,IAAZ;AACD,C,CAED;;;AACA,OAAO,SAASC,YAAT,GAKL;AAAA;;AACA,QAAM;AAAED,IAAAA,IAAF;AAAQE,IAAAA;AAAR,MAAuBX,OAAO,EAApC;AACA,QAAMY,KAAK,GAAGnB,cAAc,EAA5B;AACA,QAAMoB,WAAW,GAAGjB,cAAc,EAAlC;AAEA,QAAM;AAAEkB,IAAAA,MAAM,EAAEC;AAAV,MAAwBpB,WAAW,CACtCqB,WAAD,IAAuBf,iBAAiB,CAACe,WAAD,EAAcP,IAAd,CADD,EAEvC;AACE;AACAQ,IAAAA,QAAQ,EAAE,MAAOf,OAAP,IAAgC;AACxC;AACA;AACAW,MAAAA,WAAW,CAACK,aAAZ,CAA0BrB,SAAS,CAACY,IAApC,EAHwC,CAKxC;;AACA,YAAMU,YAAY,GAAGN,WAAW,CAACO,cAAZ,CAA2BvB,SAAS,CAACY,IAArC,CAArB,CANwC,CAQxC;;AACAE,MAAAA,UAAU,CAACT,OAAD,CAAV,CATwC,CAWxC;;AACA,aAAO;AAAEiB,QAAAA;AAAF,OAAP;AACD,KAfH;AAgBEE,IAAAA,OAAO,EAAE,CAACC,MAAD,EAASC,QAAT,EAAmBC,OAAnB,KAA+B;AACtC;AACA,UAAIA,OAAJ,aAAIA,OAAJ,uBAAIA,OAAO,CAAEL,YAAb,EAA2B;AACzBR,QAAAA,UAAU,CAACa,OAAD,aAACA,OAAD,uBAACA,OAAO,CAAEL,YAAV,CAAV;AACD;AACF,KArBH;AAsBEM,IAAAA,SAAS,EAAGC,QAAD,IAA2B;AACpC,UAAIA,QAAJ,EAAc;AACZ;AACA;AACAd,QAAAA,KAAK,CAAC;AAAEe,UAAAA,KAAK,EAAE,cAAT;AAAyBC,UAAAA,MAAM,EAAE;AAAjC,SAAD,CAAL;AACD;AACF,KA5BH;AA6BEC,IAAAA,SAAS,EAAE,MAAM,CACf;AACD;AA/BH,GAFuC,CAAzC;AAqCA,SAAOd,SAAP;AACD;;GAhDeL,Y;UAMeV,O,EACfP,c,EACMG,c,EAEUD,W","sourcesContent":["import { useCustomToast } from 'components/app/hooks/useCustomToast';\nimport jsonpatch from 'fast-json-patch';\nimport { UseMutateFunction, useMutation, useQueryClient } from 'react-query';\nimport { queryKeys } from 'react-query/constants';\n\nimport type { User } from '../../../../../shared/types';\nimport { axiosInstance, getJWTHeader } from '../../../axiosInstance';\nimport { useUser } from './useUser';\n\n// for when we need a server function\nasync function patchUserOnServer(\n  newData: User | null,\n  originalData: User | null,\n): Promise<User | null> {\n  if (!newData || !originalData) return null;\n  // create a patch for the difference between newData and originalData\n  const patch = jsonpatch.compare(originalData, newData);\n\n  // send patched data to the server\n  const { data } = await axiosInstance.patch(\n    `/user/${originalData.id}`,\n    { patch },\n    {\n      headers: getJWTHeader(originalData),\n    },\n  );\n  return data.user;\n}\n\n// TODO: update type to UseMutateFunction type\nexport function usePatchUser(): UseMutateFunction<\n  User,\n  unknown,\n  User,\n  unknown\n> {\n  const { user, updateUser } = useUser();\n  const toast = useCustomToast();\n  const queryClient = useQueryClient();\n\n  const { mutate: patchUser } = useMutation(\n    (newUserData: User) => patchUserOnServer(newUserData, user),\n    {\n      // onMutate returns context that is passed to onError\n      onMutate: async (newData: User | null) => {\n        // cancel any outdoing queries for user data, so old server data\n        // doesn't overwrite our optimistic update\n        queryClient.cancelQueries(queryKeys.user);\n\n        // snapshot of previuos user value\n        const prevUserData = queryClient.getQueriesData(queryKeys.user);\n\n        // optimistically update the cache with new user value\n        updateUser(newData);\n\n        // return the context object with snapshotted value\n        return { prevUserData };\n      },\n      onError: (_error, _newData, context) => {\n        // roll back cache to saved value\n        if (context?.prevUserData) {\n          updateUser(context?.prevUserData);\n        }\n      },\n      onSuccess: (userData: User | null) => {\n        if (userData) {\n          // no longer need it after implementing onMutate\n          // updateUser(userData);\n          toast({ title: 'User updated', status: 'success' });\n        }\n      },\n      onSettled: () => {\n        // invalidate user data (query) to make sure we're in syncwith server data\n      },\n    },\n  );\n\n  return patchUser;\n}\n"]},"metadata":{},"sourceType":"module"}